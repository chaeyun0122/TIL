# 알고리즘 복잡도 표현 방법

## 알고리즘 복잡도 계산이 필요한 이유
* 하나의 문제를 푸는 알고리즘은 다양할 수 있다.
* **다양한 알고리즘 중 어느 알고리즘이 더 좋은지를 분석하기 위해서 복잡도를 정의하고 계산한다.**  
  
* ex)
  > 정수의 절대값 구하기  
  >  - 방법 1 : 정수 값을 제곱한 값에 다시 루트를 씌우기
  >  - 방법 2 : 정수가 음수인지 확인해서 음수일 때만 -1 곱하기
  > 어떤 알고리즘이 더 좋은가?
  
  

## 알고리즘 복잡도 계산 항목
1. 시간 복잡도 : 알고리즘 실행 속도
2. 공간 복잡도 : 알고리즘이 사용하는 메모리 사이즈
  
  > 이 둘이 알고리즘의 주요한 표현방식  
  > 가장 중요한 **시간복잡도**를 꼭 이해하고 계산할 수 있어야함!
  
  
### 알고리즘 시간 복잡도의 주요 요소
> **반복문**
- 입력의 크기가 커지면 커질수록 반복문이 알고리즘 수행시간을 지배함
  
  

## 알고리즘 성능 표기법
1. Big O(빅-오) 표기법 : O(N)
 - 알고리즘 최악의 실행 시간을 표기
 - 가장 많이/ 일반적으로 사용함 -> **아무리 최악의 상황이라도 이정도의 성능을 보장한다는 의미이기 때문**  
  
2. Ω (오메가) 표기법 : Ω(N)
 - 알고리즘 최상의 실행 시간을 표기  
  
3. Θ (세타) 표기법 : Θ(N)
 - 알고리즘 평균 실행 시간을 표기  
  
  > 시간 복잡도 계산은 반복문이 핵심 요소임을 인지하고, 계산 표기는 최상, 평균, 최악 중 **최악의 시간인 Big-O 표기법을 중심으로 익혀야한다.**
  
  
### Big-O 표기법 : O(입력값)
* 입력 n에 따라 결정되는 시간 복잡도 함수
* O(1), O($ log n $), O(n), O(n$ log n $), O($ n^2 $), O($ 2^n $), O(n!)등으로 표기함
* 입력 n의 크기에 따라 기하급수적으로 시간 복잡도가 늘어날 수 있음
 - **O(1) < O($ log n $) < O(n) < O(n$ log n $) < O($ n^2 $) < O($ 2^n $) < O(n!)**  
* 단순하게 입력 n에 따라 몇 번 실행되는지를 계산하면 된다.
 - **표현식에 가장 큰 영향을 미치는 n의 단위로 표기한다.**
 1. O(1) : n값이 무엇이든 무조건 상수번 실행한다.
   ```python
     if n > 10:
       print(n)
   ```
 2. O(n) : n에 따라 n번, n+10번 또는 3n+10번 등 실행한다.
   ```python
     # 이 경우 1+3n번 -> 그래도 시간 복잡도는 O(n)
     variable = 1
     for num in range(3):
       for index in range(n):
         print(index)
   ```
 3. O($ n^2 $) : n에 따라 $ n^2 $번, $ n^2 $+1000 번, 100$ n^2 $-100 또는 300$ n^2 $+1번등 실행한다.
   ```python
     # 이 경우 1+300$ n^2 $번 -> 그래도 시간 복잡도는 O($ n^2 $)
     variable = 1
     for i in range(300):
       for num in range(n):
         for index in range(n):
           print(index)
   ```  
  <img src="http://www.fun-coding.org/00_Images/bigo.png"/>

 - 초반에는 O($ n^2 $)의 성능이 O(n)보다 좋아보이지만 입력값을 무한정으로 늘리면 O(n)이 O($ n^2 $)보다 성능이 좋다
  
  
## 실제 알고리즘을 예로 각 알고리즘의 시간 복잡도와 빅 오 표기법 알아보기
> 1부터 n까지의 합을 구하는 알고리즘 작성해보기  
  
### 알고리즘1
```python
def sum_all(n):
  total = 0
  for num in range(1, n+1):
    total += num
  return total

sum_all(100)  # 5050
```
* **알고리즘1의 시간 복잡도**
 - 입력 n에 따라 덧셈을 n번 해야함(반복문!)
 > 시간 복잡도: **n**  
 > 빅 오 표기법: **O(n)** 
  
### 알고리즘2
<font size=5em>$$\frac { n (n + 1) }{ 2 }$$</font>
```python
def sum_all(n):
  return int(n * (n * 1) / 2)

sum_all(100)  # 5050
```
* **알고리즘2의 시간 복잡도**
 - 입력 n이 어떻든 간에 곱셈/덧셈/나눗셈만 하면 됨(반복문이 없음!)
  > 시간 복잡도: **1**  
  > 빅 오 표기법: **O(1)** 
  

### 어느 알고리즘의 성능이 좋은가?
* O(n) vs O(1)
* -> 알고리즘2 성능이 더 좋다!
  
> 이와 같이, 동일한 문제를 푸는 알고리즘은 다양할 수 있고 어느 알고리즘이 보다 좋은지를 객관적으로 비교하기 위해, 빅 오 표기법등의 시간복잡도 계산법을 사용한다.
 
