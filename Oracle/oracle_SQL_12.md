# 기타 스키마 객체 생성
## 뷰
* 하나 이상의 테이블에 있는 데이터의 부분 집합을 논리적으로 나타낸다.
## 시퀀스
* 숫자 값을 생성
## 인덱스
* 데이터 검색 query의 성능을 향상시킨다.

### 인덱스 생성 지침
* 인덱스화된 열이 표현식의 일부로 참조되는 경우
![image](https://user-images.githubusercontent.com/79209568/115106495-263c4580-9fa0-11eb-85f3-84cb3a614921.png)
![image](https://user-images.githubusercontent.com/79209568/115106503-2b00f980-9fa0-11eb-855d-78af4e3bce76.png)

## 동의어
* 객체에 대체 이름을 부여한다.


```SQL
SELECT * FROM V$VERSION;

SELECT * FROM EMP;
SELECT * FROM SCOTT.EMP;

CREATE TABLE T1 
(C1    VARCHAR2(5),
 C2    CHAR(5), 
 C3    LONG, 
 C4    CLOB)
TABLESPACE USERS ; 

INSERT INTO T1 VALUES ('ABC','ABC','ABC','ABC') ;
COMMIT ; 

SELECT * FROM T1 ; 

SELECT DUMP(C1), DUMP(C2)
FROM T1 ; 

CREATE TABLE T2 
(C1   NUMBER, 
 C2   NUMBER(4,2), -- 전체 4자리에서 소수점 자리 2자리 최대값 99.99 
 C3   NUMBER(4,0), -- (4)와 같음 전체 4자리 최대값 9999.
 C4   NUMBER(2,4), -- 최대값 0.0099
 C5   NUMBER(2,-2));  -- 9900.
 
INSERT INTO T2 VALUES ( 1.23E5, 99.99, 9999, 0.0099, 9900) ;
SELECT * FROM T2 ;

SELECT SYSDATE + TO_YMINTERVAL('1-5') --오늘로부터 1년 5개월 후의 날짜
FROM DUAL ; 

DROP TABLE T2;
SELECT * FROM T2;

-- DROP 한 테이블 다시 살리기
SHOW RECYCLEBIN;

-- 조회
SELECT * FROM "BIN$asVq+P00QAaUtgv1bOXvfQ==$0";

FLASHBACK TABLE T2 TO BEFORE DROP;
SELECT * FROM T2;

--DROP TABLE T1 PURGE;
--DROP TABLE T2 PURGE;
-------------------------------------------------
CREATE TABLE EMP2 
AS SELECT * FROM EMP ; 

CREATE TABLE DEPT2 
AS SELECT * FROM DEPT ; 

ALTER TABLE DEPT2 
ADD CONSTRAINT DEPT2_PK PRIMARY KEY(DEPTNO) ;

ALTER TABLE EMP2 
ADD CONSTRAINT EMP2_PK PRIMARY KEY(EMPNO) ;

ALTER TABLE EMP2 
MODIFY ENAME NOT NULL ; 

ALTER TABLE EMP2
ADD (EMAIL VARCHAR2(10));

UPDATE EMP2 
SET EMAIL = ENAME ; 

COMMIT;

ALTER TABLE EMP2 
ADD CONSTRAINT EMP2_UK UNIQUE (EMAIL);

ALTER TABLE EMP2 
ADD CHECK (SAL > 0) ; 

ALTER TABLE EMP2 
ADD FOREIGN KEY(DEPTNO) REFERENCES DEPT2(DEPTNO) ; 

-----FOREIGN KEY 제약조건
UPDATE EMP2
SET EMPNO = 1234;

UPDATE EMP2
SET ENAME = NULL;

UPDATE EMP2
SET EMAIL = NULL; -- 가능

UPDATE EMP2
SET EMAIL = 'ABC';

UPDATE EMP2
SET SAL = -1000;

UPDATE EMP2
SET SAL = NULL; -- CHECK 제약 조건 가능

UPDATE EMP2
SET DEPTNO = 50;

DELETE DEPT2
WHERE DEPTNO = 40; --가능 (40을 쓰는 사원이 없기 때문에)

DELETE DEPT2
WHERE DEPTNO = 30; /* 오류 ( FOREIGN 제약조건에 ON DELETE CASCADE를 추가했으면 부서번호 30을 쓰는 사원들이 다 함께 삭제됨) 
                                              ON DELETE SET NULL을 추가했으면 부서번호가 30인 사원들의 DEPTNO가 NULL값이 된다. */
                                              
-----------
SELECT * FROM USER_TABLES ;

SELECT * FROM DBA_TABLES; -- 전체 테이블 (하나 누르고 CTRL+A를 누르면 전체 인출 행을 확인 가능)

SELECT * 
FROM DBA_VIEWS 
WHERE VIEW_NAME = 'DBA_TABLES' ; 

CREATE VIEW EMPV10
AS
SELECT * FROM EMP WHERE DEPTNO = 10;
-- 뷰를 만든다는 것은 쿼리문을 TEXT로 저장한다는 뜻
-- 따라서 뷰의 이름을 불러오는 것은 SQL문을 실행하는 것

SELECT * FROM EMPV10;
-- =
SELECT * FROM (SELECT * FROM EMP WHERE DEPTNO = 10 ) ; 

UPDATE EMPV10
SET SAL = 6000
WHERE EMPNO = 7782;

SELECT * FROM EMPV10;

SELECT * FROM EMP WHERE EMPNO = 7782 ; 
-- 실제 값이 수정되는 것은 원본 테이블이다.

UPDATE EMPV10
SET DEPTNO = 20 
WHERE EMPNO = 7782 ; 

SELECT * FROM EMPV10 ;
-- 바뀐게 보이지 않음(EMPV10가 DEPTNO 10을 보여주는 뷰이기 때문에
SELECT * FROM EMP WHERE EMPNO = 7782 ; 

ROLLBACK;


CREATE OR REPLACE VIEW EMPV10 
AS 
SELECT EMPNO, ENAME, SAL*12 ANN_SAL, DEPTNO 
FROM EMP 
WHERE DEPTNO = 10
WITH CHECK OPTION  ; 

SELECT * FROM EMPV10 ; 

UPDATE EMPV10 
SET ENAME = 'ABC' 
WHERE EMPNO = 7782 ; 

UPDATE EMPV10 
SET ANN_SAL = 24000
WHERE EMPNO = 7782 ; 

UPDATE EMPV10 
SET DEPTNO = 20 
WHERE EMPNO = 7782 ;  -- 오류 WITH CHECK OPTION때문에

ROLLBACK;

----------ROWNUM
SELECT ROWNUM, EMPNO, ENAME
FROM EMP;
-- 행번호. 저장 되어있지않음 쓸때마다 새로 부여

----------시퀀스
CREATE SEQUENCE EMP_SQ 
START WITH 1000 ;

SELECT * FROM USER_SEQUENCES ; 


SELECT EMP_SQ.NEXTVAL 
FROM DUAL ; --번호가 1000~ 1020까지 만들어져있다.
-- 20 이상이면 다음 20개의 캐시가 다시 주어진다

-----------동의어
-- 객체가 복제되는 것은 아니고 이름하나 더 붙여놓는 것
SELECT * FROM SCOTT.EMP ; 

CREATE SYNONYM SEMP FOR SCOTT.EMP ; 

SELECT * FROM SEMP ;

----------인덱스
DROP TABLE T1 PURGE;

CREATE TABLE T1 
AS SELECT * FROM DBA_OBJECTS ; 

SELECT * 
FROM T1 A 
WHERE 4 < (SELECT COUNT(*)
             FROM T1 
			WHERE DATA_OBJECT_ID = A.DATA_OBJECT_ID) ;

CREATE INDEX T1_IX ON T1(DATA_OBJECT_ID);

SELECT ROWID, E.*
FROM EMP E
WHERE ROWID='AAAWzkAAAAAAAObAAD'; -- 한개의 행을 검색하는 것 중 가장 빠른 방법
-- ROWID는 물리적인 행의 주소

CREATE INDEX EMP_IX ON EMP(EMPNO) ;  -- 이걸 실행하면

-- 이런 형태로 
SELECT EMPNO, ROWID 
FROM EMP 
ORDER BY 1,2 ; -- 정렬되어 들어감


SELECT * FROM EMP WHERE SAL + 0 =3000;
```
